\documentclass{ximera}  
\title{Recursion}  
\begin{document}  
\begin{abstract}  
We introduce recursion and recursively defined functions.
\end{abstract}  
\maketitle

\section{Recursion}

Recursion is involved when an object's definition refers to itself. We illustrate this idea via an example.

The factorial function is defined over the nonnegative integers in the following way: $0!=0$, for $n\geq 1$, $n!=n(n-1)(n-2)\cdots 1$. Note that in order to compute $n!$ for $n>2$, one first needs to compute $(n-1)!$. So we can define the factorial function one number at a time. We let $$n!=\begin{cases} 1 & \text{if $n=0,1$}\\ n\cdot(n-1)! & \text{otherwise.}\end{cases}$$

This new way of defining $n!$ highlights the idea that to solve the problem of computing $n!$, one first must solve the similar, but smaller problem, of computing $(n-1)!$. Recursion typically comes up when this is the case.

Another example of recursion is given by the \link[Fibonacci sequence]{https://plus.maths.org/content/fibonacci-sequence-brief-introduction}. We define $f_n$, the $n$th Fibonacci number, for $n\geq 0$ as $$f_n=\begin{cases} 1 & \text{if $n=0,1$}\\ f_{n-1}+f_{n-2} & \text{otherwise.}\end{cases}$$ Computing recursively, we see that this definition yields the sequence $1,1,2,3,5,8,\dots$. That is, for every $n\geq 2$, $f_n$ is the sum of the previous two terms in the sequence. We implement this function in Python below.

\begin{sageCell}
def fib(n):
        if n < 2:
                return 1
        else:
                return fib(n-1) + fib(n-2)

fib(5)
\end{sageCell}

Every recursively defined function has two key ingredients:

	\begin{enumerate}
	\item the base case(s): these are known values of the function that will be used as a starting point for computing other values and 
	\item the inductive case: this is the rule for computing the function at unknown values using previously known values.
	\end{enumerate}

If either ingredient above is missing, then the function will not be defined correctly. (Can you think of why?)

Some advantages of using recursively defined functions:

	\begin{itemize}
		\item Recursively definied functions can be easy to implement in Python.
		\item In many cases recursion is the only known way to define certain functions.

	\end{itemize}

A major dissadvantage of using a recursive definition is that it can require a lot of time to compute something. For example, computing $f_{100}$ in Python will take an extremely long period of time. This happens because the Python function either `forgets' that it has already computed a certain quantity. In the case of $f_{100}$, the program will first attempt to compute $f_{99}$ first, but to compute that it will first attempt to compute $f_{98}$ and so on. After finally evaluating $f_{99}$ it will attempt to compute $f_{98}$ again, not realizing that it has done that before. In a future lesson we will discuss how we can reduce the time needed to compute such values.

Another well-known example of a problem with a recursive solution is the \link[Tower of Hanoi]{https://www.mathsisfun.com/games/towerofhanoi.html} problem. In this problem, if we define $H(n)$ to be the minimum number of moves needed to move the $n$ disk tower from one post to another, then $$H(n) = \begin{cases}1 & \text{if $n=1$}\\ 2H(n-1) + 1 & \text{otherwise.}\end{cases}$$ While this is clearly recursive, it can also be shown (using an inductive proof) that $H(n)=2^n-1$. (Being able to give an explicit formula this way is not possible in every case.)

\section{Problems}

Note that for the first two questions below, the first hint contains the solution.

\begin{question}
Implement the recursive definition of $H(n)$.
	\begin{hint}
\begin{sageCell}
def H(n):
        if n == 1:
                return 1
        else:
		return 2*H(n-1)+1
\end{sageCell}
	\end{hint}
\end{question}

\begin{question}
Suppose you can climb a set of stairs by either taking one stair or three stairs at once per step. In how many ways can you climb 9 stairs?
	\begin{hint}
\begin{sageCell}
def stair(n):
        if n == 1:
                return 1
        elif n == 2:
                return 1
        elif n == 3:
                return 2
        else:
                return stair(n-3)+stair(n-1)
print(stair(9))
\end{sageCell}
\end{hint}
\end{question}

\begin{question}
McDonald's used to sell nuggets only in packages of size 6, 9, and 20. What is the largest number of nuggest that cannot be ordered using such sizes? $\answer{43}$
	\begin{hint}
If a number $n$ can be ordered, then either $n=6,9,20$ or one of $n-6$, $n-9$, or $n-20$ can be ordered.
	\end{hint}
	\begin{hint}
\begin{sageCell}
def nugget(n):
        if n < 6:
                return 0
        if n == 6 or n == 9 or n == 20:
                return 1
        else:
                return max(nugget(n-6),nugget(n-9),nugget(n-20))
\end{sageCell}
	\end{hint}
\end{question}

\section{Workspace}

\begin{sageCell}
# Use this cell to solve the above questions.
\end{sageCell}

\end{document}
