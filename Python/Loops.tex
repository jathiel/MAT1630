\documentclass{ximera}  
\title{Loops}  
\begin{document}  
\begin{abstract}  
We give an introduction to for and while loops.
\end{abstract}  
\maketitle

\section{Loops}

Loops are useful whenever you have an algorithm that requires multiple uses of the same step. For example, say we wanted to compute the sum $1+2+\cdots+100$. We have seen in a previous section that this can be done using two variables, one that tracks the current value of the sum and another that tracks whether or not our task is finished (see the flowchart below).

\begin{center}
	    \includegraphics{gausssum2.png}
\end{center}

The structure of the flowchart above is very suggestive of why we use the terminology `loop'. We will now go over two types of loops: for loops and while loops.

\section{For Loops}

The Python syntax for a for loop is as follows:

\begin{verbatim}
==============================

for variable in iterable:
        code

==============================
\end{verbatim}

In the above code, \verb|for| indicates the start of a for loop, \verb|variable| is just a variable name of your choice, \verb|in| is a keyword, and \verb|iterable| is a Python object that can be iterated over, like a list. This Python code almost reads as an English statement. It is saying, for each item in \verb|iterable|, whose value we assign to \verb|variable| each time, perform the instructions given by \verb|code|.

Below is an example of how to compute $1+2+\cdots+100$ using a for loop. 

\begin{sageCell}
n = 100
s = 0

for i in range(1,101):
        s = s + i

s
\end{sageCell}

The \verb|range| function above is commonly used in for loops. The inputs for the \verb|range| function are similar to those used for list slicing. See the SageCells below for examples of how to use the \verb|range| function.

The range function with 1 argument.
\begin{sageCell}
for i in range(10):
     print(i)
\end{sageCell}

The range function with 2 arguments.
\begin{sageCell}
for j in range(2,8):
     print(j)
\end{sageCell}

The range function with 3 arguments.
\begin{sageCell}
for k in range(3,12,2):
     print(k)
\end{sageCell}

\section{While Loops}

The Python syntax for a while loop is as follows:

\begin{verbatim}
==============================

while condition:
        code

==============================
\end{verbatim}

In the above code, \verb|while| indicates the start of a while loop, \verb|condition| is the comparison that is made to determine if the while loop is finished, and \verb|code| is executed as long as \verb|condition| holds true.

Below is an example of how to compute $1+2+\cdots+100$ using a while loop.

\begin{sageCell}
n = 100
s = 0
i = 1

while n>=i:
        s = s + i
	i = i + 1

s
\end{sageCell}

Note that for a while loop, if \verb|condition| is always true, then your algorithm will never finish running. Unlike a for loop, you must be sure to update the variables associated with the condition being checked at each iteration. In the example above, omitting the line \verb|i = i + 1| would create an infinite loop.

\section{Choices}

A common question when learning about these two types of loops is: Which one should I use? In many cases either will work just fine. For loops are preferred when the number of times the instructions are to be repeated is known. While loops are preferred when the number of times the instructions are to be repeated is unknown.

What is the smallest positive integer $n$ that has exactly $5$ divisors? You can use a loop to tackle this question by testing the number of divisors of $1$, $2$, and so on until the desired condition is met. Since it is unclear how big $n$ is, using a while loop here would be reasonable.

\section{Problems}

Note that for the questions below, the hint contains the solution.

\begin{question}
	Write a Python function \verb|pos_floor| that computes the floor of a positive real number $x$.
\begin{hint}
\begin{sageCell}
def pos_floor(x):
        i = 0
        while i <= x:
                i = i + 1
        return i - 1
\end{sageCell}
\end{hint}
\end{question}

\begin{question}
	Write a Python function \verb|neg_floor| that computes the floor of a negative real number $x$
\begin{hint}
\begin{sageCell}
def neg_floor(x):
        i = 0
        while i > x:
                i = i - 1
        return i
\end{sageCell}
\end{hint}
\end{question}

\begin{question}
	Write a Python function \verb|my_floor| that computes the floor of any real number $x$.
\begin{hint}
\begin{sageCell}
def my_floor(x):
	if x == 0:
                flr = 0
        elif x > 0:
                flr = pos_floor(x)
        else:
                flr = neg_floor(x)
        return flr
\end{sageCell}
\end{hint}
\end{question}

\begin{question}
	Write a Python function \verb|div| that computes the number of divisors of a positive integer $n$.
\begin{hint}
\begin{sageCell}
def div(n):
        d = 0
        for i in range(1,n+1):
                if n%i == 0:
                        d = d + 1
        return d
\end{sageCell}
\end{hint}
\end{question}

\begin{question}
	Write a Python \verb|fac| function that computes $n!$ for any nonnegative integer $n$.
\begin{hint}
\begin{sageCell}
def fac(n):
        if n == 0:
                f = 1
        else:
                f = 1
                for i in range(1,n+1):
                        f = f * i
        return f
\end{sageCell}
\end{hint}
\end{question}

\section{Workspace}

\begin{sageCell}
# Use this cell to solve the above questions.
\end{sageCell}

\end{document}
